future_expec = 4395),
first.date = '2006-01-15',
last.date = '2023-01-01',
format.data = 'wide'
)
ibovespa <- read_excel("ibovespa.xls") %>%
filter(Data >2005.12)
ibovespa <- ibovespa[,2]
colnames(ibovespa) <- c("ibovespa")
finance <- GetBCBData::gbcbd_get_series(
c(irf_m = 12461,
#ima_s = 12462,
ima_b = 12466,
ima = 12469,
saving_deposits = 1838,
selic = 4390,
cdi = 4391,
tjlp = 256
),
first.date = '2006-01-15',
last.date = '2023-01-01',
format.data = 'wide'
) %>% select_monthly()
finance <- finance %>%
mutate(ibovespa)
finance <- GetBCBData::gbcbd_get_series(
c(irf_m = 12461,
ima_s = 12462,
ima_b = 12466,
ima = 12469,
saving_deposits = 1838,
selic = 4390,
cdi = 4391,
tjlp = 256
),
first.date = '2006-01-15',
last.date = '2023-01-01',
format.data = 'wide'
) %>% select_monthly()
finance <- finance %>%
mutate(ibovespa)
View(finance)
credit = GetBCBData::gbcbd_get_series(
c(cred_total = 28183,
cred_gdp = 28215,
indebt_house_19882 = 19882, # %
indebt_house_20400 = 20400), # %
first.date = '2006-01-15',
last.date = '2023-01-01',
format.data = 'wide'
)
View(credit)
gov <- GetBCBData::gbcbd_get_series(
c(net_debt_gdp = 4513,
net_debt = 4478,
net_debt_fedgov_bcb = 4468,
net_debt_states = 4472,
net_debt_cities = 4473,
primary_result = 4649,
debt_fedgov_old = 4502,
debt_fedgov_new = 13761,
treasury_emit = 4151,
treasury_mkt = 4154,
treasury_term = 10616,
treasury_dur = 10617),
first.date = '2006-01-15',
last.date = '2023-01-01',
format.data = 'wide'
)
inter <- GetBCBData::gbcbd_get_series(
c(reer = 11752,
usd_brl_end = 3695,
usd_brl_avg = 3697,
current_account = 22701,
trade_balance = 22707,
imports = 22709),
first.date = '2006-01-15',
last.date = '2023-01-01',
format.data = 'wide'
)
for (k in 2:12) {
########################
## unindo dataframes ###
########################
df <- list(prices, commodities, real_sector, employment, electricity,
confidence,finance, credit, gov, inter) %>%
reduce(full_join, by='ref.date')
#################################################################
# 1) extract the variable names from the columns of df
# 2) extract names within the column "variables" in the .xlsl file
# Later we will create a correspondence between the names
################################################################
#df <- head(df,-1)
names_df <- colnames(df[,-1])
names_variables <- variable_description$variable
##########
# lags ###
##########
for (i in 1:length(names_df)) {
position <- which(names_variables == names_df[i])
lag_value <- variable_description$lag[position]
name <- names_df[i]
df[,name] <- lead(df[,name],n = lag_value)
}
rm(i)
# 4) defina valor de "k": quantos periodos voce quer acumular as variaveis (ou tirar a
#    diferenca X(t) - X(t-k))
#k <- 3
##############################
## applying transformations ##
##############################
######################
# Transformation 1: ##
######################
cols_1 <- c("bm_broad",
"bm",
"m1",
"m2",
"m3",
"m4",
"icbr",
"icbr_agr",
"icbr_metal",
"icbr_energy",
"ibcbr",
"pimpf",
"pimpf_extract",
"pimpf_manufac",
"retail_total",
"retail_fuel",
"retail_supermarket",
"retail_clothing",
"retail_house",
"retail_drugstore",
"retail_paper",
"retail_office",
"retail_others",
"retail_building",
"retail_auto",
"prod_vehicles",
"prod_agr_mach",
"vehicle_sales",
"min_wage",
"aggreg_wage",
"elec",
"elec_com",
"elec_res",
"elec_ind",
"cons_confidence",
"future_expec",
"irf_m",
"ima_s",
"ima_b",
"ima",
"saving_deposits",
"cred_total",
"debt_fedgov_old",
"debt_fedgov_new",
"treasury_emit",
"treasury_mkt",
"reer",
"usd_brl_end",
"usd_brl_avg",
"current_account",
"trade_balance",
"imports")
df <- df %>%
mutate_at(vars(all_of(cols_1)), ~acumula_indice_mensal(., k))
#######################
# Transformation 2: ###
#######################
cols_2 <- c("ipca_ali",
"ipca_hab",
"ipca_resid",
"ipca_vest",
"ipca_transp",
"ipca_comunic",
"ipca_saude",
"ipca_desp",
"ipca_educ",
"ipc_BR",
"igp_M",
"igp_DI",
"igp10",
"ipca15")
df <- df %>%
mutate_at(vars(all_of(cols_2)), ~acumula_var_mensal(., k))
#######################
# Transformation 3: ###
#######################
cols_3 <- c("tcu",
"unem",
"cred_gdp",
"indebt_house_19882",
"indebt_house_20400",
"net_debt_gdp",
"net_debt",
"net_debt_fedgov_bcb",
"net_debt_states",
"net_debt_cities",
"primary_result",
"treasury_term",
"treasury_dur")
df <- df %>%
mutate_at(vars(all_of(cols_3)), ~ lag(c(rep(NA,c(k-1)),diff(., c(k-1))),1))
#######################
#names_df <- names_df[-1]
#names_variables <- names_variables[-1]
#for (i in 1:length(names_df)) {
#  position <- which(names_variables == names_df[i])
#  transf <- variable_description$transformation[position]
#  name <- names_df[i]
#  if(transf == 1){
#    df[,name] <- acumula_indice_mensal(df[,name],k)
#  }
#  if(transf == 2){
#    df[,name] <- acumula_var_mensal(df[,name],k)
#  }
#  if(transf == 3){
#    df[,name] <- diff(df[,name],c(k-1))
#  }
#}
#rm(i)
df[,"ipca"] <- acumula_var_mensal(df[,"ipca"],12)
df <- df %>% mutate(ipca0 = ipca,
ipca1 = lag(ipca,1),
ipca2 = lag(ipca,2))
####################
# ADICIONANDO FOCUS
###################
focus <- get_twelve_months_inflation_expectations(indic = c("IPCA"),
start_date = "2005-01-01",
end_date = "2022-02-01") %>%
filter(smoothed == "N",
base == 0) %>%
select(date,median) %>%
group_by(year(date), month(date)) %>%
filter(day(date) == max(day(date)))%>%
ungroup() %>%
select(date,median)%>%
arrange(date)
# forçando dias a serem registrados como "01"
day(focus$date) <- 01
focus <- head(focus,-1)#apago a ultima linha pois queria end_date = "2022-01-01", mas tive que escrever end_date = "2022-02-01" por conta de um bug
df <- df %>% mutate(focus = focus$median)
#####################
# Ajustes finais ###
####################
# a data ta um periodo a frente
#df$ref.date <- df$ref.date %m+% months(1)
# quero deixar coluna do ipca um ano a frente, logo:
df <- df %>%
mutate(ipca = lead(ipca,11)) # usar comando de alguma funcao de dates
# por fim, para deixar as linhas baseadas nas datas das observacoes do ipca, como
# trouxe o ipca 12 casas pra baixo, fareio mesmo com as datas;
df$ref.date <- df$ref.date %m+% years(1)
# como ultimas 12 linhas nao tem observacoes de ipca, posso deleta-las
df <- head(df, -12)
# como primeiras 11 linhas nao tem observacoes do ipca, deleto
df <- df[-c(1:11),]
# ajeitando rownames
df <- remove_rownames(df)
# ver dataframe df
saveRDS(df, file = paste0("df",k,".rds"))
}
k=1
df <- list(prices, commodities, real_sector, employment, electricity,
confidence,finance, credit, gov, inter) %>%
reduce(full_join, by='ref.date')
names_df <- colnames(df[,-1])
names_variables <- variable_description$variable
for (i in 1:length(names_df)) {
position <- which(names_variables == names_df[i])
lag_value <- variable_description$lag[position]
name <- names_df[i]
df[,name] <- lead(df[,name],n = lag_value)
}
rm(i)
df[,"ipca"] <- acumula_var_mensal(df[,"ipca"],12)
df <- df %>% mutate(ipca0 = ipca,
ipca1 = lag(ipca,1),
ipca2 = lag(ipca,2))
focus <- get_twelve_months_inflation_expectations(indic = c("IPCA"),
start_date = "2005-01-01",
end_date = "2022-02-01") %>%
filter(smoothed == "N",
base == 0) %>%
select(date,median) %>%
group_by(year(date), month(date)) %>%
filter(day(date) == max(day(date)))%>%
ungroup() %>%
select(date,median)%>%
arrange(date)
# forçando dias a serem registrados como "01"
day(focus$date) <- 01
focus <- head(focus,-1)#apago a ultima linha pois queria end_date = "2022-01-01", mas tive que escrever end_date = "2022-02-01" por conta de um bug
df <- df %>% mutate(focus = focus$median)
df <- df %>%
mutate(ipca = lead(ipca,11)) # usar comando de alguma funcao de dates
# por fim, para deixar as linhas baseadas nas datas das observacoes do ipca, como
# trouxe o ipca 12 casas pra baixo, fareio mesmo com as datas;
df$ref.date <- df$ref.date %m+% years(1)
# como ultimas 12 linhas nao tem observacoes de ipca, posso deleta-las
df <- head(df, -12)
# como primeiras 11 linhas nao tem observacoes do ipca, deleto
df <- df[-c(1:11),]
# ajeitando rownames
df <- remove_rownames(df)
saveRDS(df, file = paste0("df",k,".rds"))
library(randomForest)
library(tidyverse)
library(HDeconometrics)
library(Metrics)
library(reshape2)
library(ggplot2)
library(ggsci)
library(gridExtra)
library(glmnet)
library(rbcb)
library(lubridate)
library(forecast)
acumulacao <- 1:12 %>% as.list()
data <- acumulacao %>%
map(~paste("~/MONOGRAFIA_TITO/data_new/df",.x,".rds",sep = "")%>%
readRDS())
# horizonte
k <- 12
# window (fixed) size: vou usar data[[1]], mas poderia ser qualquer outro
window <- data[[1]] %>% filter(ref.date <"2014-01-01") %>% nrow()
y <- data[[1]] %>% #(poderia usar qualquer um dos dfs de data)
select(ipca) %>%
as.matrix()
# matriz de regressores
X <- data %>%
map(~.x %>%
select(-c(ref.date,ipca))%>%
select_if(~ !any(is.na(.))) %>% # tirando colunas com NA
as.matrix())
# numero de previsoes (igual pra todos)
size <- nrow(data[[1]]) - window - 1
# valores observados (out of sample)
y_obs <- y[(window+1):nrow(data[[1]])]
csr <- list()
for (i in 1:length(data)) {
csr[[i]] <- 0:size %>%
map_dbl(
function(x){ csr(X[[i]][(1+ x):(window+ x), ],
y[(1+ x):(window+ x)]) %>%
predict(X[[i]][(window+x+1), ])}
)
}
library(randomForest)
library(tidyverse)
library(HDeconometrics)
library(Metrics)
library(reshape2)
library(ggplot2)
library(ggsci)
library(gridExtra)
library(glmnet)
library(rbcb)
library(lubridate)
library(forecast)
acumulacao <- 1:12 %>% as.list()
data <- acumulacao %>%
map(~paste("~/MONOGRAFIA_TITO/data_new/df",.x,".rds",sep = "")%>%
readRDS())
# horizonte
k <- 12
# window (fixed) size: vou usar data[[1]], mas poderia ser qualquer outro
window <- data[[1]] %>% filter(ref.date <"2014-01-01") %>% nrow()
y <- data[[1]] %>% #(poderia usar qualquer um dos dfs de data)
select(ipca) %>%
as.matrix()
# matriz de regressores
X <- data %>%
map(~.x %>%
select(-c(ref.date,ipca))%>%
select_if(~ !any(is.na(.))) %>% # tirando colunas com NA
as.matrix())
# numero de previsoes (igual pra todos)
size <- nrow(data[[1]]) - window - 1
# valores observados (out of sample)
y_obs <- y[(window+1):nrow(data[[1]])]
rf <- list()
for (i in 1:length(data)) {
rf[[i]] <- 0:size %>%
map_dbl(
function(x){ randomForest(X[[i]][(1+ x):(window+x), ],
y[(1+ x):(window+ x)]) %>%
predict(X[[i]][(window+x + 1), ])}
)
}
lasso <- list()
for (i in 1:length(data)) {
lasso[[i]] <- 0:size %>%
map_dbl(
function(x){ cv.glmnet(X[[i]][(1+ x):(window+ x), ],
y[(1+ x):(window+ x)], alpha = 1, crit = "bic") %>%
predict(X[[i]][(window+x + 1), ])}
)
}
lasso_select <- list()
for (i in 1:length(data)) {
lasso_select[[i]] <- 0:size %>%
map(
function(x){
ic_fit <- ic.glmnet(X[[i]][(1+ x):(window+ x), ],
y[(1+ x):(window+ x)], alpha = 1, crit = "bic")
unlist(coef(ic_fit, s = "lambda.min"))[-1] %>%
names() %>% # Extract variable names
as.character() # Convert to character vector
}
)
}
# Combine all frequency tables into one using dplyr's bind_rows()
lasso_freq <- lasso_select %>%
map(~.x %>% unlist() %>% table() %>% as.data.frame() %>%
rename("freq" = "."))
combined_df <- bind_rows(lasso_freq, .id = "id") %>%
group_by(id, freq) %>%  # group by common columns
summarize(total_freq = sum(Freq))  # summarize the frequency
# Keep only unique combinations of id and freq
combined_df <- unique(combined_df[, c("id", "freq", "total_freq")])
ridge <- list()
for (i in 1:length(data)) {
ridge[[i]] <- 0:size %>%
map_dbl(
function(x){ cv.glmnet(X[[i]][(1+ x):(window+ x), ],
y[(1+ x):(window+ x)], alpha = 0, crit = "bic") %>%
predict(X[[i]][(window+x + 1), ])}
)
}
csr <- list()
for (i in 1:length(data)) {
csr[[i]] <- 0:size %>%
map_dbl(
function(x){ csr(X[[i]][(1+ x):(window+ x), ],
y[(1+ x):(window+ x)]) %>%
predict(X[[i]][(window+x+1), ])}
)
}
#####################
# 3.5) Random Walk ##
#####################
rw <- list()
for (i in 1:(size+1)) {
# fit a random walk model to the current window
rw_model <- rwf(y[(i):(i+window-1)])
# make a one-step-ahead forecast using the fitted model
next_val <- forecast(rw_model)$mean
# store the forecast in the list
rw[[i]] <- next_val
}
rw <- rw %>%
map(. %>% unique(.))%>%
unlist()
rw <- rep(list(rw), 12)
prediction <- pmap(
list(rf,lasso,csr), function(first,second,third){
cbind(first, second, third)
}
) %>%
map(~.x %>%
as.data.frame %>%
rename("RF" = first,
"LASSO" = second,
"CSR" = third
))
prediction <- map2(prediction,ridge,cbind) %>%
map(~.x %>%
rename("RIDGE" = ".y[[i]]"))
prediction <- map2(prediction,rw,cbind) %>%
map(~.x %>%
rename("RW" = ".y[[i]]"))
error <- prediction %>%
map(~y_obs - .x)
rmse <- prediction %>%
map(. %>%
summarise_all(~rmse(y_obs, .))
)
rm(rmse)
rmse <- prediction %>%
map(. %>%
summarise_all(~rmse(y_obs, .))
)
mae <- prediction %>%
map(. %>%
summarise_all(~mae(y_obs, .)) %>%
round(3))
mad <- error %>%
map(. %>%
summarise_all(~mad(.)))
rmse <- map(rmse,as.data.frame) %>%
bind_rows()
mae <- map(mae,as.data.frame) %>%
bind_rows()
mad <- map(mad,as.data.frame) %>%
bind_rows()
# 5.4.2) Benchmark RMSE
#focus <- head(focus,-1)#apago a ultima linha pois queria end_date = "2022-01-01", mas tive que escrever end_date = "2022-02-01" por conta de um bug
focus <- data[[1]]$focus
focus <- focus[(window+1):nrow(data[[1]])]
rmse_focus <- rmse(y_obs,focus)
# 5.4.3) Normalizing rmse with rmse_focus
rmse_normal <- rmse/rmse_focus
rmse_normal <- round(rmse_normal,3)
rmse_normal
setwd("~/MONOGRAFIA_TITO/data_new")
# Save workspace
setwd("~/MONOGRAFIA_TITO/data_new")
save.image("workspace_2014_corrected.RData")
